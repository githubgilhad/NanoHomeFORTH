// ***************************************************************
// *****      Assembly HSYNC (TIMER0) interrupt vector       *****
// ***** by Carsten Herting (slu4), last update: 17.07.2023  *****
// ***** copy 'os.h' and 'os.S' into '/Arduino/libraries/os' *****
// ***************************************************************

#define __SFR_OFFSET 0x00		// set the Special Function Register Offset from 0x20 to 0x00 in order to use AVR PORT definitions
#include <avr/io.h>			// include PORTB, DDRD, ... symbols for easier register access
#include "buffer.h"
#include "bios.h"
//.extern BIOS::charset
.extern BIOS::chardef
.section .bss
prev: .byte 0				// PS/2 previous sample of CLK, used for edge detection
cnts: .byte 0				// PS/2 received bits counter
data: .word 0				// PS/2 datagram as it is received bit by bit
.section .text
; PORTD D0-7 RX0 TX1 D2-7 8bit data out
; PORTB B4 D12 = HSYNC
; PORTB B3 D11 = 74HC166 Latch
; PORTB B0 D8 - 16 MHZ
; PORTB B1 D9 - VSYNC od RCA = unused
; PORTB B5 D13 INSIDE (not Led)
; PINC  C0 A0 Clock PS/2 - handled by regHandler
; PINC  C1 A1 Data PS/2
; PORTC C2-5 A2-5 RGBY out
.balign 64
.global TIMER0_COMPA_vect		// define this global to make the Arduino IDE integrate the ISR
.global VGA_hook
VGA_hook:	ret

// ***************************************************************

.macro ONECHAR				//     Z: address of char data (MSB is fixed, LSB depends on char), X: current VRAM position (one line)
	ld    ZL, X+			// 2CP ZL = (X), X = X + 1
	lpm   r21, Z			// 3CP get font byte from program memory for current chr on current line
	out   PORTD, r21		// 1CP put data to shift register's parallel input
	out   PORTB, r24		// 1CP /PE LOW (next CLK rising edge will load pixel data)
	out   PORTB, r23		// 1CP /PE HIGH (now CLK will pump out 8 pixels)
	nop
 .endm

// ***************************************************************

TIMER0_COMPA_vect:			// ISR table entry is automatically generated by the AVR assembler
	push r1				// save r1 and r0 (r0-1 are modified by the result of a multiplication)
	push r0
	in   r0, SREG			// reads the AVR status register SREG 0x3f holding the complete flag state
	push r0				// push it on the stack, too
	
	push r20			// push content on stack, so we can use this register right away
	
;	nop
	lds  r20, TCNT2			// interrupt jitter compensation using timer TCNT2
	cpi  r20, 4
	breq .+8
	cpi  r20, 3
	breq .+6
	cpi  r20, 2
	breq .+4
	nop
	nop
	nop
	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
	
	cbi PORTB, 4			// start HSYNC pulse by hand
	
	push  r21			// push current values of registers to be used onto stack
	push  r22
	push  r23
	push  r24
	push  r25
	push  r26			// X
	push  r27
	push  r30			// Z
	push  r31

	lds r20, vline+0		// load vline to r20-21
	lds r21, vline+1
	movw r24, r20			// copy register pair r20/21 -> r24/25
	adiw r24, 1			// increase vline by 1
	sts vline+1, r25		// and save back
	sts vline+0, r24
	lsr r21				// divide vline by 2 and subtract 30 ??? lsr also okay??
	ror r20
	subi r20, 30			// r20 = pixel line "lin"

	sbi PORTB, 4			// ??? end HSYNC (after only 1µ, should be 3,8µs but this buys valuable time here)

	in r22, PINC			// r22 = scan PS/2 keyboard state (CLK and DAT) every 32µs
	// Note: This is not quite fast enough to cover the full PS/2 spec
	// (10.0 - 16.7kHz) but works fine with all PS/2 keyboards I have checked.
	
	mov r21, r20			// calculate VRAM row address from lin
	lsr r21
	lsr r21
	lsr r21				// lin>>3 = row number
	ldi r23, BIOS_COLS
	mul r23, r21			// ATTENTION: calculate * 40 => RESULT is in r0-r1!!!
	movw r30, r0			// RESULT r0-1 to r30-31 (Z): index of VRAM row

	ldi r24, 0			// needed for add with carry (see below)
	ldi XL, lo8(cram)		// output the row color to pins A2-A5 (C2-C5)
	ldi XH, hi8(cram)
	add XL, r21			// add row number index to start address
	adc XH, r24			// takes a potential carry flag into account
	ld r21, X 			// load row color from (X)
	lsl r21				// shift color info 2 steps up to C2..5
	lsl r21
	ori r21, 3			// make sure the 20k-pull-ups stay always on for PS/2 CLK and DAT
	out PORTC, r21			// output color information

	ldi XL, lo8(vram)
	ldi XH, hi8(vram)
	add XH, ZH			// add VRAM row index to VRAM start address
	add XL, ZL			// r26-27 = X = VRAM row address
	adc XH, r24			// takes a potential carry flag into account
	
	mov r21, r20			// get lin a 2nd time
	andi r21, 7			// only use lowest 3 bits of lin to determin charset line

	lds ZH, chardef+1		// load address of pointer 'chardef' to Z
;	ldi ZL, lo8(chardef)
;	ld ZH, Z		// load its high byte to Z. low byte is zero, becasuse charset MUST be 256 aligned
;	ldi ZH, hi8(charset)		// charset must be aligned to 256 bytes
	add ZH, r21			// now ZH points to the charset line

	in r23, PORTB			// prepare the two different /PE states for ultra-fast switching
	mov r24, r23			// r23: B3=1
	andi r24, 0x37			// r24: B3=0

	cpi r20, 200			// draw 200 scanlines (25 x 8)
	brcs drawPixels
	jmp regHandler			// regHandler handles PS/2

drawPixels:
	ldi r20, 8 ;10			// shifts screen left BUT BE CAREFUL: if routine takes too long, it won't fit into a scanline!
wait:	dec r20
	brne wait
	nop
	nop
	
	ONECHAR			// transmit 40 characters at a rate of 2MHz (16MHz pixel clock)
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
;	ONECHAR
;	ONECHAR
;	ONECHAR
	
;	ONECHAR
;	ONECHAR
	
regHandler:				// regHandler handles PS/2                                                 ;
;sei; ???
	mov r23, r22                                                                                               ;
	andi r23, 2			// r23 = isolated DAT in bit1                                              ;
	andi r22, 1			// r22 = isolated current CLK in bit0, operation sets Z flag               ;
	breq regLow			// CLK = 0?                                                                ;
                                                                                                                   ;
	lds r30, data+1			// CLK = 1!                                                                ;
	cpi r30, 0			// high byte will contain at least the high stop bit if data is present    ;
	breq regEnd			// don't do anything if no data is present                                 ;
                                                                                                                   ;
	lds r30, cnts			// we have data! => Check for end of datagram...                           ;
	inc r30                                                                                                    ;
	sts cnts, r30			// cnts++                                                                  ;
	cpi r30, 8			// cnts >= 8?                                                              ;
	brlo regEnd                                                                                                ;
                                                                                                                   ;
	ldi ZH, hi8(BIOS_buffer)	// DATAGRAM finished! => prepare Z for an indirect store                   ;
	ldi ZL, lo8(BIOS_buffer)                                                                                   ;
	lds r21, BIOS_buffer_head_ptr	// load direct from data space: "BIOS_buffer_head_ptr" index               ;
	mov r24,r21			// save for later
	add ZL, r21                                                                                                ;
	ldi r21, 0                                                                                                 ;
	adc ZH, r21                                                                                                ;
	                                                                                                           ;
	lds r21, data+0			// load low PS/2 data byte (start bit is shifted out)                      ;
	st Z, r21			// store scan code -> (Z)                                                  ;
	                                                                                                           ;
;	lds r30, BIOS_buffer_head_ptr	// again load "BIOS_buffer_head_ptr" index for incrementation              ;
	; let use r24 instead
	inc r24				// BIOS_buffer_head_ptr++                                                  ;
	andi r24, BUFFER_MASK		// only use 16 bytes for KEYBUFSIZE (wrap around)                          ;
	lds r21, BIOS_buffer_tail_ptr	// check if full                                                           ;
	cp r21, r24                                                                                                ;
	breq buf_is_full                                                                                           ;
	sts BIOS_buffer_head_ptr, r24	// store BIOS_buffer_head_ptr back to data space                           ;
buf_is_full:                                                                                                       ;
	ldi r30, 0                                                                                                 ;
	sts data+1, r30			// invalidate the PS/2 data by setting MSB to zero                         ;
	jmp regEnd                                                                                                 ;
                                                                                                                   ;
regLow:                                                                                                            ;
	lds r21, prev			// CLK = 0! => load previous CLK state                                     ;
	cp r22, r21			// compare the two CLK states for a change                                 ;
	breq regEnd			// CLK falling edge?                                                       ;
                                                                                                                   ;
	ldi r30, 0                                                                                                 ;
	sts cnts, r30			// reset the counter after rising edge                                     ;
	lds r20, data			// load data into r20-21                                                   ;
	lds r21, data+1                                                                                            ;
	lsr r21				// shift data one step down                                                ;
	ror r20                                                                                                    ;
	or  r21, r23			// insert the (previous) DAT as bit9                                       ;
	sts data+0, r20   		// store data                                                              ;
	sts data+1, r21                                                                                            ;
                                                                                                                   ;
regEnd:                                                                                                            ;
	sts prev, r22			// remember the state of CLK                                               ;
	pop r31				// restore previous values of used registers                               ;
	pop r30				// Z                                                                       ;
	pop r27                                                                                                    ;
	pop r26				// X                                                                       ;
	pop r25                                                                                                    ;
	pop r24                                                                                                    ;
	pop r23                                                                                                    ;
	pop r22                                                                                                    ;
	pop r21                                                                                                    ;
	pop r20                                                                                                    ;
	pop r0				// restore the AVR status register SREG 0x3f value                         ;
	out SREG, r0			// set the SREG back to what it was                                        ;
	pop r0				// restore r0, r1                                                          ;
	pop r1                                                                                                     ;
	reti				// return from interrupt                                                   ;
/*                                                                                                                 
	-----------                                                                                                
	MIT License                                                                                                
	-----------                                                                                                
	Copyright (c) 2023 Carsten Herting                                                                         
	Permission is hereby granted, free of charge, to any person obtaining a copy of                            
	this software and associated documentation files (the "Software"), to deal in                              
	the Software without restriction, including without limitation the rights to                               
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies                              
	of the Software, and to permit persons to whom the Software is furnished to do                             
	so, subject to the following conditions:                                                                   
	The above copyright notice and this permission notice shall be included in all                             
	copies or substantial portions of the Software.                                                            
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/
